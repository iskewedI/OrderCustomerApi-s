--- A microservices practice using .NET Core 3.1

-APi's don't directly call each other to update data.
-APi's uses .NET Core 3.1 Web Api with DI/IoC
-They use a queue to communicate among them.
-Use DDD and CQRS approaches with Mediator and Repository Pattern.
-They uses in-memory database.
-Swagger is implemented.
-Setted up in a Docker container.
-Uses RabbitMQ.

-Using API's, the consumers are unknowns and existing features should not be broken.
-To extend API's => use versioning (v1, v2, etc) => Only when new changes were to break the functionality.

-Controllers =>
    -Only call different services and return a model or status to the client.
    -They don't do any business logic.
-Validators
    -Used to validate user input.
    -FluentValidations is used -> NuGet package.
    -Validators inherits from AbstractValidator and T is the clas of the model to validate.
-Data 
    -Contains everything needed to access the DB.
    -The DB context is created for every request.
-Domain
    -Contains all entities and no business logic
-Messaging.Send
    -Contains everything I need to send Customer objects to a RabbitMQ queue.
-Service
    -Splitted into Command and Query -> CQRS separate concerns of reading and writing data.
    -Commands WRITE data and Queries READ data.
    -Both has an action that should be executed and its particular handler.
    -The handler often calls the repository to retrieve or change data.